<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Text Mining</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="1_class_notes_files/libs/clipboard/clipboard.min.js"></script>
<script src="1_class_notes_files/libs/quarto-html/quarto.js"></script>
<script src="1_class_notes_files/libs/quarto-html/popper.min.js"></script>
<script src="1_class_notes_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="1_class_notes_files/libs/quarto-html/anchor.min.js"></script>
<link href="1_class_notes_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="1_class_notes_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="1_class_notes_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="1_class_notes_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="1_class_notes_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Text Mining</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Data is often associated with rigid structures: neat rows and columns forming orderly tables. Each row represents an observation, while columns contain variables with information about these observations, encoded as either continuous or categorical data. Continuous variables take numerical form, while categorical ones present as textual data. Within this schema, textual data tends to be concise, often referencing closed or open categories.</p>
<p>However, Artificial Intelligence (AI) houses a specialized field that transcends this conventional view, considering human language as data itself. <strong>Natural Language Processing (NLP)</strong> sits at the intersection of computer science and linguistics, aiming to imbue computers with the ability to mimic human comprehension of text. Its goal is to enable machines to grasp the essence of various textual forms such as news articles, social media posts, and more. The inherent challenge lies in the fact that such information primarily exists as unstructured data. While we effortlessly discern content and information through reading, a computer initially encounters it as a string of characters. NLP seeks out patterns within this unstructured data to facilitate text interpretation.</p>
<p>Some examples of useful NLP applications are:</p>
<ul>
<li>Sentiment analysis</li>
<li>Text translation</li>
<li>Chat bots</li>
<li>Text classification (e.g., detecting hate speech)</li>
</ul>
</section>
<section id="structuring-text-data" class="level1">
<h1>Structuring text data</h1>
<p>Text data’s unstructured nature means it typically appears in two main formats:</p>
<ul>
<li><strong>String:</strong> Imagine text stored as plain character sequences in R. This is often the initial format for raw text data.</li>
<li><strong>Corpus:</strong> These collections go beyond strings and include annotations with metadata and other details.</li>
</ul>
<p><strong>In the NLP world, we impose structure by transforming text into “tokens”.</strong> These tokens are meaningful units, dividing input strings <span class="citation" data-cites="silge">(<a href="#ref-silge" role="doc-biblioref">Silge and Hvitfeldt, n.d.a</a>)</span>. Think of them as words, but they can also be groups of words (n-grams<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>), sentences, or even paragraphs. The initial text preprocessing step involves segmenting the corpus into tokens, based on your chosen definition of what constitutes a token. This structured approach differs from simply storing raw text.</p>
<p><strong>Once we have individual tokens, converting them into a matrix is crucial.</strong> This allows us to represent the text quantitatively and consistently. A popular method is the <strong>“Bag of Words” (BOW)</strong> approach. Think of BOW as a matrix where each row represents a document (a self-contained text unit like an article or tweet) and each column represents a unique token. The values in the matrix show how often each token appears within each document.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://vitalflux.com/wp-content/uploads/2021/08/Bag-of-words-technique-to-convert-to-numerical-feature-vector-png.png"><img src="img/bow.png" class="img-fluid figure-img" width="577" alt="Analytics Yogi"></a></p>
<figcaption>Analytics Yogi</figcaption>
</figure>
</div>
<p>As a result, each word is associated with a vector:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://vitalflux.com/wp-content/uploads/2021/08/Bag-of-words-technique-to-convert-to-numerical-feature-vector-png.png"><img src="img/bow_vector.png" class="img-fluid figure-img" width="437" alt="Analytics Yogi"></a></p>
<figcaption>Analytics Yogi</figcaption>
</figure>
</div>
<p><strong>This type of representation presumes independence between words.</strong> It solely reflects the occurrence of terms within each document, disregarding the connections between them and contextual details. With this BOW matrix, the terms can be plotted.</p>
<p><img src="img/word_freq.png" class="img-fluid"></p>
<section id="zipfs-law" class="level2">
<h2 class="anchored" data-anchor-id="zipfs-law">Zipf’s Law</h2>
<p>This previous visualization depicts the frequency of the 96 most common terms across documents. The sheer number of features is readily apparent, as evidenced by the high dimensionality of the matrices. Notably, certain words shine brighter due to their significantly higher frequency compared to others. This hints at <strong>Zipf’s Law</strong> from quantitative linguistics, where a word’s frequency inversely correlates with its ranking in the frequency table.</p>
<p>For example, given the word frequency and rank of the words in Jane Austen books:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 40,379 × 4
   book              word      n  rank
   &lt;fct&gt;             &lt;chr&gt; &lt;int&gt; &lt;int&gt;
 1 Mansfield Park    the    6206     1
 2 Mansfield Park    to     5475     2
 3 Mansfield Park    and    5438     3
 4 Emma              to     5239     4
 5 Emma              the    5201     5
 6 Emma              and    4896     6
 7 Mansfield Park    of     4778     7
 8 Pride &amp; Prejudice the    4331     8
 9 Emma              of     4291     9
10 Pride &amp; Prejudice to     4162    10
# ℹ 40,369 more rows</code></pre>
</div>
</div>
<p>Visualizing Zipf’s Law involves plotting word rank on the x-axis and term frequency on the y-axis, both on logarithmic scales. This reveals an intriguing pattern: an inversely proportional relationship between word rank and frequency. In other words, words with higher ranks appear less frequently, while lower-ranked words show greater frequency.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="1_class_notes_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="stop-words" class="level2">
<h2 class="anchored" data-anchor-id="stop-words">Stop words</h2>
<p>Zipf’s Law and frequency visualizations reveal a key concept: certain overly common words offer little meaningful information. These <strong>“stop words”</strong> are frequently removed during text preprocessing before analysis. Conversely, extremely infrequent words also hold limited value and often get excluded. This selective removal improves the accuracy and relevance of subsequent analyses.</p>
<p>There are three main types of stop words <span class="citation" data-cites="silgea">(<a href="#ref-silgea" role="doc-biblioref">Silge and Hvitfeldt, n.d.b</a>)</span>:</p>
<ol type="1">
<li><p><strong>Global stop words:</strong> These have minimal meaning across most contexts and languages. Think of English words like “the”, “of” and “and.” These act as connectors, not content carriers.</p></li>
<li><p><strong>Subject-specific stop words:</strong> These lack meaning within a specific domain. Analyzing U.S. education, words like “high”, “school”, or “student” might not help differentiate institutions. They could become stop words for such an analysis, often requiring manual curation.</p></li>
<li><p><strong>Document-level stop words:</strong> These provide little to no information within a specific document. They’re challenging to identify and offer limited benefit for tasks like regression or classification, even if discovered.</p></li>
</ol>
</section>
<section id="stemming" class="level2">
<h2 class="anchored" data-anchor-id="stemming">Stemming</h2>
<p>One challenge in text analysis is dealing with <strong>word variations</strong>. Consider the word “change”. It might appear as “change”, “changing”, “changed” or “changes”. While each gets counted as a separate feature in Bag of Words, we often want to treat them as equivalent. This is the idea behind <strong>stemming</strong>, the process of identifying the base word (or stem) for a data set of words <span class="citation" data-cites="silgeb">(<a href="#ref-silgeb" role="doc-biblioref">Silge and Hvitfeldt, n.d.c</a>)</span>.</p>
<p>Different stemming algorithms use various rules to remove prefixes and suffixes, grouping words with the same stem. In our “change” example, all four variants might be reduced to “chang”. It’s crucial to remember that stemming is a heuristic approach, not always producing a proper linguistic root but aiming to condense variations of a word to a common form.</p>
</section>
<section id="lemmatization" class="level2">
<h2 class="anchored" data-anchor-id="lemmatization">Lemmatization</h2>
<p>Another method for reducing words to their base form is lemmatization <span class="citation" data-cites="stemming">(<a href="#ref-stemming" role="doc-biblioref"><span>“Stemming and Lemmatization,”</span> n.d.</a>)</span>. Unlike stemming, which applies heuristic rules, lemmatization considers the meaning and context of words.</p>
<p>In lemmatization, words are transformed into their lemma, which is the canonical or dictionary form. This process involves using vocabulary analysis and morphological analysis of words to return their base or dictionary form (known as the lemma) by considering the part of speech and the context of the word. For example, the words “changing”, “changed”, “changes” and “change” would all be transformed into “change”. This approach ensures that the transformed words belong to the language and carry real meaning. However, lemmatization requires detailed dictionaries<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> and linguistic knowledge compared to stemming, making it more accurate but computationally more expensive due to the complexity of linguistic analysis involved.</p>
<p>It’s important to note that both lemmatization and stemming aim to <em>reduce the feature space of the dataset</em>, similar to preprocessing steps in machine learning. However, it’s not always necessary to perform stemming or lemmatization. These preprocessing steps should be carefully considered, taking into account domain knowledge of the problem being addressed.</p>
</section>
</section>
<section id="other-representations-of-text" class="level1">
<h1>Other representations of text</h1>
<p>So far, we’ve explored how text can be represented in a feature space using a Bag of Words (BOW) matrix. In this matrix, each document is depicted as a row, with individual tokens serving as its features. This representation, also known as a <strong>Document-Term-Matrix (DTM)</strong>, can also be transposed into a <strong>Term-Document-Matrix (TDM)</strong>, where tokens are rows and documents are features. Within this matrix, each cell denotes the frequency of a specific term occurring in a particular document.</p>
<p>However, these BOW approaches only tally the total frequency of terms and assume independence between them within a document. They fail to consider the relevance of terms to individual documents within the entire corpus. To address this limitation, we employ the <strong>Term Frequency-Inverse Document Frequency (TF-IDF) matrix</strong>. TF-IDF is a numerical statistic that reflects the importance of a term in a document relative to the collection of documents. Here’s how it works:</p>
<ul>
<li><p><strong>Term Frequency (TF)</strong>: This component measures how frequently a term appears in a document. It’s calculated as the ratio of the number of times a term (t) appears in a document (d) to the total number of terms in that document. Essentially, TF tells us how relevant a term is within a specific document.</p>
<p><span class="math inline">\(\text{TF}(t, d) = \frac{\text{Number of times term } t \text{ appears in document } d}{\text{Total number of terms in document } d}\)</span></p></li>
<li><p><strong>Inverse Document Frequency (IDF)</strong>: IDF quantifies the rarity of a term across the entire corpus. It’s calculated as the logarithm of the total number of documents in the corpus (N) divided by the number of documents containing the term t. This means that terms that occur in many documents will have a lower IDF, while terms that occur in fewer documents will have a higher IDF. IDF helps in identifying terms that are distinctive to certain documents.</p>
<p><span class="math inline">\(\text{IDF}(t, D) = \log{\frac{\text{N: Total number of documents in corpus D}}{\text{df(t): Number of documents containing term t}}}\)</span></p></li>
<li><p><strong>TF-IDF Score</strong>: The TF-IDF score for a term in a document is calculated by multiplying the TF and IDF values for that term.</p>
<p><span class="math inline">\(\text{TF-IDF}(t, d, D) = \text{TF}(t, d) \times \text{IDF}(t, D)\)</span></p></li>
</ul>
<p>The resulting TF-IDF score captures the importance of a term in a document while considering both its frequency within the document (TF) and its uniqueness across the entire corpus (IDF). Terms with high TF-IDF scores are those that appear frequently in a specific document but are relatively rare across the corpus, making them highly informative for that document. Conversely, terms with low TF-IDF scores may be common across many documents and hence less informative or distinctive.</p>
<p>In summary, TF-IDF is a powerful tool for extracting important information from text data by weighting terms based on their relevance within individual documents and their uniqueness across the entire corpus.<br>
This approach also serves to address stop words by reducing the weight of common words that frequently appear in the text corpus. These common words often lack significant meaning or importance in the context of the document. As a result, the TF-IDF method provides a more accurate assessment of term importance by down-weighting such stop words.</p>
</section>
<section id="distances-between-documents" class="level1">
<h1>Distances between documents</h1>
<p>After transforming our corpus into a matrix of terms, we can perform mathematical operations on it. As we’ve described, once transformed, the tokens are represented as <em>vectors</em>. Consequently, each document has a vectorial representation, allowing us to leverage <strong>cosine similarity</strong> to measure the similarity between them. This metric evaluates the similarity in the direction or orientation of the vectors while disregarding differences in their magnitude or scale. The similarity is computed as the cosine of the angle between them, as depicted by the following formula:</p>
<p><span class="math display">\[
cos(\theta) = \frac{{A}\cdot{B}}{\lVert A \rVert \lVert B \rVert}
\]</span></p>
<p>Where:</p>
<ul>
<li><p><span class="math inline">\({A} \cdot {B}\)</span> denotes the dot product of the two vectors A and B.</p></li>
<li><p><span class="math inline">\(\lVert A \rVert \lVert B \rVert\)</span> represent the L2 norm or magnitude of each vector.</p></li>
</ul>
<p>The resulting value is the cosine of the angle between these two vectors. In the realm of natural language processing (NLP), this metric gauges the <em>correlation</em> between documents based on attributes that exist in a non-numerical space. Its range is between 0 and 1, where:</p>
<ul>
<li>The similarity is 1 when the documents are exactly identical.</li>
<li>The similarity is 0 when the documents don’t share any similar words.</li>
</ul>
</section>
<section id="regular-expressions" class="level1">
<h1>Regular Expressions</h1>
<p>When dealing with text data, we often encounter the need to process strings of text that follow consistent patterns. For instance, we might want to capture cases with the same suffix, identify text-number-text patterns, or extract authors from academic citations with a specific format. To accomplish these tasks, we rely on a powerful tool known as <strong>Regular Expressions (Regex)</strong>. Regex comprises a sequence of characters that define a search pattern. With regex, we can:</p>
<ul>
<li><p>Search: Identify patterns within text.</p></li>
<li><p>Validate: Determine if a string conforms to a particular pattern.</p></li>
<li><p>Replace: Modify text by substituting specific patterns.</p></li>
<li><p>Extract: Capture specific portions of text that match a pattern.</p></li>
</ul>
<p>Regular expressions are constructed by combining smaller expressions using various operators <span class="citation" data-cites="r:regul">(<a href="#ref-r:regul" role="doc-biblioref"><span>“R: Regular Expressions as Used in r,”</span> n.d.</a>)</span>. The basic components are regular expressions that match a single character. Most characters, including letters and digits, are regular expressions that match themselves.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view_all</span>(<span class="st">"Hello, my name is ... and I am 20 years old."</span>, <span class="st">"Hello"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] │ &lt;Hello&gt;, my name is ... and I am 20 years old.</code></pre>
</div>
</div>
<p>Special characters, such as punctuation marks, should be referenced by preceding them with a double backslash in R.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view_all</span>(<span class="st">"Hello, my name is ... and I am 20 years old."</span>, <span class="st">"</span><span class="sc">\\</span><span class="st">..."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] │ Hello, my name is &lt;...&gt; and I am 20 years old.</code></pre>
</div>
</div>
<p>A character class is a list of characters enclosed between ‘⁠[⁠’ and ‘⁠]⁠’ which matches any single character in that list.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view_all</span>(<span class="st">"Hello, my name is ... and I am 20 years old."</span>, <span class="st">"[aeoi]"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] │ H&lt;e&gt;ll&lt;o&gt;, my n&lt;a&gt;m&lt;e&gt; &lt;i&gt;s ... &lt;a&gt;nd I &lt;a&gt;m 20 y&lt;e&gt;&lt;a&gt;rs &lt;o&gt;ld.</code></pre>
</div>
</div>
<p>The special character ‘^’ negates the characters enclosed within brackets.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view_all</span>(<span class="st">"Hello, my name is ... and I am 20 years old."</span>, <span class="st">"[^aeoi]"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] │ &lt;H&gt;e&lt;l&gt;&lt;l&gt;o&lt;,&gt;&lt; &gt;&lt;m&gt;&lt;y&gt;&lt; &gt;&lt;n&gt;a&lt;m&gt;e&lt; &gt;i&lt;s&gt;&lt; &gt;&lt;.&gt;&lt;.&gt;&lt;.&gt;&lt; &gt;a&lt;n&gt;&lt;d&gt;&lt; &gt;&lt;I&gt;&lt; &gt;a&lt;m&gt;&lt; &gt;&lt;2&gt;&lt;0&gt;&lt; &gt;&lt;y&gt;ea&lt;r&gt;&lt;s&gt;&lt; &gt;o&lt;l&gt;&lt;d&gt;&lt;.&gt;</code></pre>
</div>
</div>
<p>Aside from these specifications, certain named classes of characters are predefined.</p>
<ul>
<li><code>[:alpha:]</code> matches all letters</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view_all</span>(<span class="st">"Hello, my name is ... and I am 20 years old."</span>, <span class="st">"[:alpha:]"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] │ &lt;H&gt;&lt;e&gt;&lt;l&gt;&lt;l&gt;&lt;o&gt;, &lt;m&gt;&lt;y&gt; &lt;n&gt;&lt;a&gt;&lt;m&gt;&lt;e&gt; &lt;i&gt;&lt;s&gt; ... &lt;a&gt;&lt;n&gt;&lt;d&gt; &lt;I&gt; &lt;a&gt;&lt;m&gt; 20 &lt;y&gt;&lt;e&gt;&lt;a&gt;&lt;r&gt;&lt;s&gt; &lt;o&gt;&lt;l&gt;&lt;d&gt;.</code></pre>
</div>
</div>
<ul>
<li><code>[:lower:]</code> matches all lower case letters</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view_all</span>(<span class="st">"Hello, my name is ... and I am 20 years old."</span>, <span class="st">"[:lower:]"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] │ H&lt;e&gt;&lt;l&gt;&lt;l&gt;&lt;o&gt;, &lt;m&gt;&lt;y&gt; &lt;n&gt;&lt;a&gt;&lt;m&gt;&lt;e&gt; &lt;i&gt;&lt;s&gt; ... &lt;a&gt;&lt;n&gt;&lt;d&gt; I &lt;a&gt;&lt;m&gt; 20 &lt;y&gt;&lt;e&gt;&lt;a&gt;&lt;r&gt;&lt;s&gt; &lt;o&gt;&lt;l&gt;&lt;d&gt;.</code></pre>
</div>
</div>
<ul>
<li><code>[:upper:]</code> matches all upper case letters</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view_all</span>(<span class="st">"Hello, my name is ... and I am 20 years old."</span>, <span class="st">"[:upper:]"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] │ &lt;H&gt;ello, my name is ... and &lt;I&gt; am 20 years old.</code></pre>
</div>
</div>
<ul>
<li><code>[:alnum:]</code> matches alphanumeric characters (letters and numbers).</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view_all</span>(<span class="st">"Hello, my name is ... and I am 20 years old."</span>, <span class="st">"[:alnum:]"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] │ &lt;H&gt;&lt;e&gt;&lt;l&gt;&lt;l&gt;&lt;o&gt;, &lt;m&gt;&lt;y&gt; &lt;n&gt;&lt;a&gt;&lt;m&gt;&lt;e&gt; &lt;i&gt;&lt;s&gt; ... &lt;a&gt;&lt;n&gt;&lt;d&gt; &lt;I&gt; &lt;a&gt;&lt;m&gt; &lt;2&gt;&lt;0&gt; &lt;y&gt;&lt;e&gt;&lt;a&gt;&lt;r&gt;&lt;s&gt; &lt;o&gt;&lt;l&gt;&lt;d&gt;.</code></pre>
</div>
</div>
<ul>
<li><code>[:digit:]</code> matches all digits.</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view_all</span>(<span class="st">"Hello, my name is ... and I am 20 years old."</span>, <span class="st">"[:digit:]"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] │ Hello, my name is ... and I am &lt;2&gt;&lt;0&gt; years old.</code></pre>
</div>
</div>
<ul>
<li><code>[:punct:]</code> matches all punctuation symbols.</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view_all</span>(<span class="st">"Hello, my name is ... and I am 20 years old."</span>, <span class="st">"[:punct:]"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] │ Hello&lt;,&gt; my name is &lt;.&gt;&lt;.&gt;&lt;.&gt; and I am 20 years old&lt;.&gt;</code></pre>
</div>
</div>
<ul>
<li><code>[:space:]</code> matches spaces and whitelines.</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view_all</span>(<span class="st">"Hello, my name is ... and I am 20 years old."</span>, <span class="st">"[:space:]"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] │ Hello,&lt; &gt;my&lt; &gt;name&lt; &gt;is&lt; &gt;...&lt; &gt;and&lt; &gt;I&lt; &gt;am&lt; &gt;20&lt; &gt;years&lt; &gt;old.</code></pre>
</div>
</div>
<p>Recall that we can combine these operators <a href="https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf">and more</a> to create expressions that match complex patterns. However, it is common to make mistakes with them as they take a long time to learn and understand how to use. Therefore, we often use websites like <a href="https://regexr.com/">RegExr</a> to write and test our regular expressions or try them out with Large Language Models to elaborate them efficiently.</p>
</section>
<section id="discussion" class="level1">
<h1>Discussion</h1>
<p>When considering bias in NLP models today, it’s often linked directly to the presence of certain stereotypes in large language models, such as those encountered when interacting with a Chat Bot or Chat GPT. These stereotypes are ingrained in human language, and when we use human-generated vocabularies for analysis, especially older language, we inevitably encounter many unequal stereotypes regarding certain communities. Through text mining approaches, we can uncover how the use of specific terms and vocabulary reflects inequalities in society. In essence, text analysis offers a valuable snapshot of society at a particular moment in time.</p>
<p>A notable example is the study by <span class="citation" data-cites="gálvez2019">Gálvez, Tiffenberg, and Altszyler (<a href="#ref-gálvez2019" role="doc-biblioref">2019</a>)</span>. In this research, the authors investigated the presence of the stereotype associating men with higher cognitive abilities than women in movie subtitles. They collected subtitles using web scraping, amassing a dataset of 11,550 film subtitles spanning half a century of film history. Employing the Pointwise Mutual Information (PMI) metric, they measured the frequency of co-occurrence between two tokens<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. Their analysis revealed how female pronouns were linked with stereotypical roles such as caregiver, homemaker, dietician, nurse, or stylist, while male pronouns were associated with roles like architect, mechanic, inventor, or sheriff. Additionally, female pronouns appeared less frequently alongside nouns denoting high cognitive abilities (e.g., intelligent, brilliant, genius) compared to male pronouns. Through this approach, the authors provided insightful analysis of cultural stereotypes within a specific societal context using text mining methods.</p>
<p>Another noteworthy study is that of <span class="citation" data-cites="twenge2012">Twenge, Campbell, and Gentile (<a href="#ref-twenge2012" role="doc-biblioref">2012</a>)</span>. They utilized the English corpus from the Google Books database, focusing on books published in the U.S. from 1800 to 2008. Analyzing the frequency of male and female pronouns across time, they observed that female pronouns began to have more representation, particularly in the post-war era following women’s increased participation in the job market. This study highlighted how cultural products, such as books, reflect changes in women’s status and shifting trends in gender equality over time.</p>
</section>
<section id="references" class="level1 unnumbered">


</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-gálvez2019" class="csl-entry" role="listitem">
Gálvez, Ramiro H., Valeria Tiffenberg, and Edgar Altszyler. 2019. <span>“Half a Century of Stereotyping Associations Between Gender and Intellectual Ability in Films.”</span> <em>Sex Roles</em> 81 (9): 643–54. <a href="https://doi.org/10.1007/s11199-019-01019-x">https://doi.org/10.1007/s11199-019-01019-x</a>.
</div>
<div id="ref-r:regul" class="csl-entry" role="listitem">
<span>“R: Regular Expressions as Used in r.”</span> n.d. <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html">https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html</a>.
</div>
<div id="ref-silge" class="csl-entry" role="listitem">
Silge, Julia, and Emil Hvitfeldt. n.d.a. <em>Chapter 2 Tokenization | Supervised Machine Learning for Text Analysis in r</em>. <a href="https://smltar.com/tokenization#what-is-a-token">https://smltar.com/tokenization#what-is-a-token</a>.
</div>
<div id="ref-silgea" class="csl-entry" role="listitem">
———. n.d.b. <em>Chapter 3 Stop Words | Supervised Machine Learning for Text Analysis in r</em>. <a href="https://smltar.com/stopwords">https://smltar.com/stopwords</a>.
</div>
<div id="ref-silgeb" class="csl-entry" role="listitem">
———. n.d.c. <em>Chapter 4 Stemming | Supervised Machine Learning for Text Analysis in r</em>. <a href="https://smltar.com/stemming#lemmatization">https://smltar.com/stemming#lemmatization</a>.
</div>
<div id="ref-stemming" class="csl-entry" role="listitem">
<span>“Stemming and Lemmatization.”</span> n.d. <a href="https://nlp.stanford.edu/IR-book/html/htmledition/stemming-and-lemmatization-1.html">https://nlp.stanford.edu/IR-book/html/htmledition/stemming-and-lemmatization-1.html</a>.
</div>
<div id="ref-twenge2012" class="csl-entry" role="listitem">
Twenge, Jean M., W. Keith Campbell, and Brittany Gentile. 2012. <span>“Male and Female Pronoun Use in U.S. Books Reflects Women<span>’</span>s Status, 1900<span></span>2008.”</span> <em>Sex Roles</em> 67 (9): 488–93. <a href="https://doi.org/10.1007/s11199-012-0194-7">https://doi.org/10.1007/s11199-012-0194-7</a>.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>An n-gram refers to a contiguous sequence of n items from a given sample of text or speech. These items can be characters, syllables, words, or even larger elements like phrases or sentences, depending on the context. The “n” in n-gram represents the number of items in the sequence.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a href="https://wordnet.princeton.edu/">W</a><a href="#0">ordnet</a> is a good dataset source to perform lemmatization of english words.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Note that the numerator indicates how often two tokens are observed together, whereas the denominator indicates how often they are expected to co-occur assuming independence.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>